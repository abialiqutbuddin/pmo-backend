	generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

/* =========================
   Enums (RBAC, FSM, etc.)
   ========================= */

enum EventRole {
  OWNER         // community owner/creator for an event
  PMO_ADMIN     // full control for event
  PMO_POC       // PMO operator
  DEPT_HEAD
  DEPT_MEMBER
  GUEST
  OBSERVER
}

enum ConversationKind {
  EVENT        // #event-general, #pmo
  DEPARTMENT   // #dept-*
  ISSUE        // auto-room bound to an Issue
  GROUP        // ad-hoc project chat
  DIRECT       // DM
}

enum IssueSeverity {
  critical
  high
  normal
  low
}

enum IssueStatus {
  open
  triaged
  in_progress
  resolved
  closed
}

enum TaskStatus {
  todo
  in_progress
  blocked
  done
  canceled
}

// Kind of task for categorization and reporting
enum TaskType {
  issue
  new_task
  taujeeh
  improvement
}

enum DependencyType {
  finish_to_start
  start_to_start
  finish_to_finish
  start_to_finish
}

enum InterDeptStatus {
  requested
  acknowledged
  rejected
  fulfilled
}

enum NotificationChannel {
  in_app
  push
  email
}

enum AuditAction {
  USER_INVITED
  ROLE_CHANGED
  DEPT_HEAD_SET
  TASK_CREATED
  TASK_UPDATED
  TASK_DELETED
  DEPENDENCY_CREATED
  DEPENDENCY_REMOVED
  DUE_DATE_CHANGED
  SLA_OVERRIDE
  ISSUE_CREATED
  ISSUE_ROUTED
  ISSUE_CONVERTED_TO_TASK
  CONVERSATION_CREATED
  MESSAGE_DELETED
}

enum MediaKind {
  image
  video
  file
}

enum StorageProvider {
  filesystem
  minio
  s3
}

/* =========================
   Users & Identity
   ========================= */

model User {
  id               String              @id @default(cuid())
  email            String              @unique
  fullName         String
  passwordHash     String
  createdAt        DateTime            @default(now())
  isDisabled       Boolean             @default(false)

  // global admin flag for cross-event features
  isSuperAdmin     Boolean             @default(false)

  // new optional fields
  itsId            String?             @unique @db.VarChar(8)
  profileImage     String?             // local file path or public URL
  organization     String?
  designation      String?
  phoneNumber      String?
  

  // memberships in events
  memberships      EventMembership[]                 // regular memberships
  invitationsSent  EventMembership[] @relation("Inviter") // rows where this user invited others

  // chat
  authoredMsgs     Message[]           @relation("MessageAuthor")
  reactions        Reaction[]
  participants     Participant[]

  // issues & tasks
  issues           Issue[]             // reporter side (matches Issue.reporter without a named relation)
  tasksAssigned    Task[]              @relation("TaskAssignee")
  tasksCreated     Task[]              @relation("TaskCreator")

  // notifications & audit
  notifications    Notification[]
  notificationPrefs NotificationPref[]
  auditLogs        AuditLog[]          @relation("AuditActor")
    // refresh sessions
  sessions         SessionToken[]

  @@index([createdAt])
}

model SessionToken {
  id              String    @id @default(cuid())
  userId          String
  // store only a strong hash of the refresh token
  tokenHash       String
  // optional device and security metadata
  userAgent       String?
  ip              String?
  issuedAt        DateTime  @default(now())
  expiresAt       DateTime
  revokedAt       DateTime?

  user            User      @relation(fields: [userId], references: [id])

  @@index([userId, expiresAt])
  @@unique([tokenHash])
}

/* =========================
   Event & Department
   ========================= */

model Event {
  id            String         @id @default(cuid())
  name          String
  startsAt      DateTime?
  endsAt        DateTime?
  createdAt     DateTime       @default(now())
  archivedAt    DateTime?

  departments   Department[]
  memberships   EventMembership[]
  conversations Conversation[]
  issues        Issue[]
  tasks         Task[]
  interDeptReqs InterDeptRequest[]
  auditLogs     AuditLog[]

  @@index([createdAt])
  NotificationPref NotificationPref[]
  Notification Notification[]
  AttachmentLink AttachmentLink[]
  Venue Venue[]
}

model Department {
  id        String   @id @default(cuid())
  eventId   String
  name      String

  event     Event    @relation(fields: [eventId], references: [id])
  members   EventMembership[]
  tasks     Task[]
  conversations Conversation[]
  issues    Issue[]
  requestsAsSource InterDeptRequest[] @relation("ReqFromDept")
  requestsAsTarget InterDeptRequest[] @relation("ReqToDept")

  @@unique([eventId, name]) // unique dept names within an event
  @@index([eventId])
}

model EventMembership {
  id           String    @id @default(cuid())
  eventId      String
  userId       String
  role         EventRole
  departmentId String?   // optional default/home dept for DEPT_* roles
  invitedById  String?
  createdAt    DateTime  @default(now())

  event        Event     @relation(fields: [eventId], references: [id])
  user         User      @relation(fields: [userId], references: [id])
  department   Department? @relation(fields: [departmentId], references: [id])
  invitedBy    User?     @relation("Inviter", fields: [invitedById], references: [id])

  @@unique([eventId, userId, departmentId])
  @@index([eventId, userId])
  @@index([role])
}

/* =========================
   Chat
   ========================= */

model Conversation {
  id            String           @id @default(cuid())
  eventId       String
  kind          ConversationKind
  title         String?
  departmentId  String?
  issueId       String?

  isArchived    Boolean          @default(false)
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  event         Event            @relation(fields: [eventId], references: [id])
  department    Department?      @relation(fields: [departmentId], references: [id])
  issue         Issue?           @relation(fields: [issueId], references: [id])

  participants  Participant[]
  messages      Message[]

  @@index([eventId, kind])
  @@index([departmentId])
  @@unique([issueId]) // one canonical room per Issue
}

model Participant {
  id              String        @id @default(cuid())
  conversationId  String
  userId          String
  role            String        @default("MEMBER") // OWNER/MEMBER/GUEST for the room
  joinedAt        DateTime      @default(now())
  lastReadAt      DateTime?
  isMuted         Boolean       @default(false)

  conversation    Conversation  @relation(fields: [conversationId], references: [id])
  user            User          @relation(fields: [userId], references: [id])

  @@unique([conversationId, userId])
  @@index([userId])
}

model Message {
  id              String        @id @default(cuid())
  conversationId  String
  authorId        String
  body            String?
  parentId        String?       // simple threads
  editedAt        DateTime?
  deletedAt       DateTime?
  createdAt       DateTime      @default(now())

  conversation    Conversation  @relation(fields: [conversationId], references: [id])
  author          User          @relation("MessageAuthor", fields: [authorId], references: [id])
  //attachments     Attachment[]
  reactions       Reaction[]
  parent          Message?      @relation("Thread", fields: [parentId], references: [id])
  replies         Message[]     @relation("Thread")

  // Fast room paging + author filters
  @@index([conversationId, createdAt])
  @@index([authorId, createdAt])
}

// model Attachment {
//   id          String   @id @default(cuid())
//   messageId   String
//   kind        MediaKind
//   objectKey   String   // file path or S3 key
//   mimeType    String
//   bytes       Int
//   width       Int?
//   height      Int?
//   createdAt   DateTime @default(now())

//   message     Message  @relation(fields: [messageId], references: [id])

//   @@index([messageId])
// }

model Reaction {
  id          String   @id @default(cuid())
  messageId   String
  userId      String
  emoji       String
  createdAt   DateTime @default(now())

  message     Message  @relation(fields: [messageId], references: [id])
  user        User     @relation(fields: [userId], references: [id])

  @@unique([messageId, userId, emoji])
  @@index([messageId])
}

/* =========================
   Issues
   ========================= */

model Issue {
  id          String        @id @default(cuid())
  eventId     String
  reporterId  String
  departmentId String?
  severity    IssueSeverity @default(normal)
  status      IssueStatus   @default(open)
  title       String
  description String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  closedAt    DateTime?
  deletedAt   DateTime?

  event       Event         @relation(fields: [eventId], references: [id])
  reporter    User          @relation(fields: [reporterId], references: [id])
  department  Department?   @relation(fields: [departmentId], references: [id])
  conversation Conversation?
  //attachments IssueAttachment[]
  tasks         Task[]   @relation("IssueTasks")
  //linkedTask  Task?         @relation("IssueTaskLink")

  @@index([eventId, severity, status])
  @@index([departmentId])
}


model Attachment {
  id           String          @id @default(cuid())
  eventId      String
  entityType   String          // "Task", "Comment", etc.
  entityId     String          // ID of that entity
  objectKey    String          @unique
  originalName String
  mimeType     String
  size         Int
  checksum     String?
  provider     StorageProvider @default(filesystem)
  createdBy    String
  createdAt    DateTime        @default(now())
  deletedAt    DateTime?

  links        AttachmentLink[]

  @@index([checksum])
  @@index([eventId, entityType, entityId])
}

model AttachmentLink {
  id           String     @id @default(cuid())
  attachmentId String
  entityType   String     // duplicate of Attachment’s owner if you multi-link to other entities
  entityId     String
  createdAt    DateTime   @default(now())

  attachment   Attachment @relation(fields: [attachmentId], references: [id], onDelete: Cascade)

  @@unique([entityType, entityId, attachmentId])   // no duplicate links
  @@index([entityType, entityId])
  Event Event[]
}

// model IssueAttachment {
//   id          String   @id @default(cuid())
//   issueId     String
//   objectKey   String
//   mimeType    String
//   bytes       Int
//   createdAt   DateTime @default(now())

//   issue       Issue    @relation(fields: [issueId], references: [id])

//   @@index([issueId])
// }

/* =========================
   Tasks & Dependencies
   ========================= */

model Task {
  id           String      @id @default(cuid())
  eventId      String
  departmentId String
  creatorId    String
  assigneeId   String?
  venueId      String?
  type         TaskType    @default(new_task)
  title        String
  description  String?
  priority     Int          @default(3) // lower = higher priority, configurable
  status       TaskStatus   @default(todo)
  progressPct  Int          @default(0)
  startAt      DateTime?
  dueAt        DateTime?
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  completedAt  DateTime?
  deletedAt    DateTime?

  event        Event        @relation(fields: [eventId], references: [id])
  department   Department   @relation(fields: [departmentId], references: [id])
  creator      User         @relation("TaskCreator", fields: [creatorId], references: [id])
  assignee     User?        @relation("TaskAssignee", fields: [assigneeId], references: [id])
  venue        Venue?       @relation(fields: [venueId], references: [id])

  //attachments  TaskAttachment[]
  blockers     TaskDependency[] @relation("Blockers")
  dependents   TaskDependency[] @relation("Dependents")
  sourceIssueId  String?
  sourceIssue    Issue?    @relation("IssueTasks", fields: [sourceIssueId], references: [id], onDelete: SetNull)

  //sourceIssue  Issue?          @relation("IssueTaskLink", fields: [id], references: [id])

  @@index([eventId, departmentId])
  @@index([status, dueAt])
  @@index([assigneeId, status])
  @@index([venueId])
  @@index([sourceIssueId])
  InterDeptRequest InterDeptRequest[]
  //Issue Issue[] @relation("IssueTasks")
}

model Venue {
  id        String   @id @default(cuid())
  eventId   String
  name      String
  createdAt DateTime @default(now())

  event     Event    @relation(fields: [eventId], references: [id])
  tasks     Task[]

  @@unique([eventId, name])
  @@index([eventId])
}

// model TaskAttachment {
//   id          String   @id @default(cuid())
//   taskId      String
//   objectKey   String
//   mimeType    String
//   bytes       Int
//   createdAt   DateTime @default(now())

//   task        Task     @relation(fields: [taskId], references: [id])

//   @@index([taskId])
// }

model TaskDependency {
  id           String         @id @default(cuid())
  upstreamId   String
  downstreamId String
  depType      DependencyType @default(finish_to_start)
  createdAt    DateTime       @default(now())

  upstream     Task           @relation("Blockers",   fields: [upstreamId],   references: [id])
  downstream   Task           @relation("Dependents", fields: [downstreamId], references: [id])

  @@unique([upstreamId, downstreamId])
  @@index([downstreamId])
}

model InterDeptRequest {
  id           String          @id @default(cuid())
  eventId      String
  fromDeptId   String
  toDeptId     String
  relatedTaskId String?
  note         String?
  status       InterDeptStatus @default(requested)
  requestedBy  String          // userId
  acknowledgedBy String?
  rejectedBy   String?
  fulfilledBy  String?
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  event        Event           @relation(fields: [eventId], references: [id])
  fromDept     Department      @relation("ReqFromDept", fields: [fromDeptId], references: [id])
  toDept       Department      @relation("ReqToDept", fields: [toDeptId], references: [id])
  relatedTask  Task?           @relation(fields: [relatedTaskId], references: [id])

  @@index([eventId, status])
  @@index([fromDeptId])
  @@index([toDeptId])
}

/* =========================
   Notifications
   ========================= */

model Notification {
  id          String     @id @default(cuid())
  userId      String
  eventId     String?
  kind        String     // e.g., TASK_ASSIGNED, TASK_OVERDUE, MENTION, INTERDEPT_ACK
  title       String
  body        String?
  link        String?    // deep link (task/issue/chat)
  readAt      DateTime?
  createdAt   DateTime   @default(now())

  user        User       @relation(fields: [userId], references: [id])
  event       Event?     @relation(fields: [eventId], references: [id])

  @@index([userId, createdAt])
  @@index([eventId, createdAt])
}

model NotificationPref {
  id          String   @id @default(cuid())
  userId      String
  eventId     String?
  kind        String
  muted       Boolean  @default(false)
  updatedAt   DateTime @updatedAt

  user        User     @relation(fields: [userId], references: [id])
  event       Event?   @relation(fields: [eventId], references: [id])

  // ✅ channels live here
  channels    NotificationPrefChannel[]

  @@unique([userId, eventId, kind])
}

model NotificationPrefChannel {
  id        String              @id @default(cuid())
  prefId    String
  channel   NotificationChannel

  pref      NotificationPref    @relation(fields: [prefId], references: [id])

  // one row per (pref, channel)
  @@unique([prefId, channel])
  @@index([channel])
}

/* =========================
   Audit & Rate Limits
   ========================= */

model AuditLog {
  id          String      @id @default(cuid())
  eventId     String?
  actorId     String?
  action      AuditAction
  entityType  String      // "Task" | "Issue" | "Conversation" | ...
  entityId    String?
  diffJson    Json?
  createdAt   DateTime    @default(now())

  event       Event?      @relation(fields: [eventId], references: [id])
  actor       User?       @relation("AuditActor", fields: [actorId], references: [id])

  @@index([eventId, createdAt])
  @@index([actorId, createdAt])
}

/**
 * Generic sliding-window counters for spam control (e.g., “issue/task creation from chat ≤ 20/min”).
 * Your service layer increments/checks rows with (userId, key) per windowStart.
 */
model RateLimitCounter {
  id           String    @id @default(cuid())
  userId       String
  key          String    // e.g., "chat_to_task", "issue_create"
  windowStart  DateTime
  count        Int       @default(0)

  @@unique([userId, key, windowStart])
  @@index([key, windowStart])
}
